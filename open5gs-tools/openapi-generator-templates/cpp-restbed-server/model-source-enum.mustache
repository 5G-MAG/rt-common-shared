{{classname}}::{{classname}}()
    :ModelObject()
    ,m_value({{classname}}::Enum::NO_VAL)
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{
}

{{classname}}::{{classname}}(const {{classname}} &other)
    :ModelObject(other)
    ,m_value(other.m_value)
    ,m_validator(other.m_validator)
{
}

{{classname}}::{{classname}}({{classname}} &&other)
    :ModelObject(std::move(other))
    ,m_value(std::move(other.m_value))
    ,m_validator(std::move(other.m_validator))
{
}

{{classname}}::{{classname}}(const std::string &json, bool as_request)
    :ModelObject()
    ,m_value()
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{
    CJson jtree = CJson::parse(json);
    this->fromJSON(jtree, as_request);
}

{{classname}}::{{classname}}(const CJson &json, bool as_request)
    :ModelObject()
    ,m_value()
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{
    this->fromJSON(json, as_request);
}

{{classname}}::~{{classname}}()
{
}

{{classname}} &{{classname}}::operator=(const {{classname}} &other)
{
    m_value = other.m_value;
    m_validator = other.m_validator;

    return *this;
}

{{classname}} &{{classname}}::operator=({{classname}} &&other)
{
    m_value = std::move(other.m_value);
    m_validator = std::move(other.m_validator);

    return *this;
}

void {{classname}}::fromJSON(const CJson &json, bool as_request)
{
    fromString(static_cast<std::string>(json));
}

CJson {{classname}}::toJSON(bool as_request) const
{
    return CJson::newString(getStringConst());
}

std::string {{classname}}::getString() const
{
    switch(m_value) {
{{#values}}
    case Enum::VAL_{{^.}}NULL{{/.}}{{#.}}{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}{{/.}}:
        return std::string({{#.}}STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}{{/.}});
{{/values}}
    default:
        break;
    }
    return std::string();
}

const char *{{classname}}::getStringConst() const
{
    switch(m_value) {
{{#values}}
    case Enum::VAL_{{^.}}NULL{{/.}}{{#.}}{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}{{/.}}:
        return STR_{{^.}}NULL{{/.}}{{#.}}{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}{{/.}};
{{/values}}
    default:
        break;
    }
    return nullptr;
}   

{{classname}} &{{classname}}::fromString(const std::string &value)
{
    if (value.empty()) {
        m_value = Enum::NO_VAL;
{{#values}}{{#.}}
    } else if (value == STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}) {
        m_value = Enum::VAL_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}};
{{/.}}{{/values}}
    }
    return *this;
}
