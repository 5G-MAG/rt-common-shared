{{#models}}{{#model}}/**************************************************************************
 * {{classname}}.cc : {{classname}} object model implementation
 *    generated from openapi-generator C++ language Mustache template
 *    for object model implementation
 **************************************************************************
 * {{description}}
 **************************************************************************
 * Template file
 * =============
 * License: 5G-MAG Public License (v1.0)
 * Author: David Waring
 * Copyright: (C)2023 British Broadcasting Corporation
 *
 * For full license terms please see the LICENSE file distributed with this
 * program. If this file is missing then the license can be retrieved from
 * https://drive.google.com/file/d/1cinCiA778IErENZ3JN52VFW-1ffHpx7Z/view
 */
#include <string>
#include <memory>

#include "CJson.hh"
#include "ModelObject.hh"
#include "ModelException.hh"
#include "OgsAllocator.hh"

#include "{{classname}}.h"

using namespace fiveg_mag_reftools;
{{#modelNamespace}}

namespace {{modelNamespace}} {
{{/modelNamespace}}

{{classname}}::{{classname}}()
    :ModelObject()
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    ,m_value({{classname}}::Enum::NO_VAL)
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    ,m_value({{classname}}::Enum::NO_VAL)
    ,m_strValue()
    ,m_validator("{{classname}}",nullptr)
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}
{{#vars}}    ,m_{{name}}()
    ,m_{{name}}_validator({{>model-validator-params}})
{{/vars}}
{
}

{{classname}}::{{classname}}(const {{classname}} &other)
    :ModelObject(other)
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    ,m_value(other.m_value)
    ,m_validator(other.m_validator)
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    ,m_value(other.m_value)
    ,m_strValue(other.m_strValue)
    ,m_validator(other.m_validator)
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}
{{#vars}}    ,m_{{name}}(other.m_{{name}})
    ,m_{{name}}_validator(other.m_{{name}}_validator)
{{/vars}}
{
}

{{classname}}::{{classname}}({{classname}} &&other)
    :ModelObject(std::move(other))
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    ,m_value(std::move(other.m_value))
    ,m_validator(std::move(other.m_validator))
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    ,m_value(std::move(other.m_value))
    ,m_strValue(std::move(other.m_strValue))
    ,m_validator(std::move(other.m_validator))
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}
{{#vars}}    ,m_{{name}}(std::move(other.m_{{name}}))
    ,m_{{name}}_validator(std::move(other.m_{{name}}_validator))
{{/vars}}
{
}

{{classname}}::{{classname}}(const std::string &json, bool as_request)
    :ModelObject()
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    ,m_value()
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    ,m_value()
    ,m_strValue()
    ,m_validator("{{classname}}",nullptr)
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}
{{#vars}}    ,m_{{name}}()
    ,m_{{name}}_validator({{>model-validator-params}})
{{/vars}}
{
    CJson jtree = CJson::parse(json);
    this->fromJSON(jtree, as_request);
}

{{classname}}::{{classname}}(const CJson &json, bool as_request)
    :ModelObject()
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    ,m_value()
    ,m_validator("{{classname}}",nullptr,"/^({{#values}}|{{{.}}}{{/values}})$/")
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    ,m_value()
    ,m_strValue()
    ,m_validator("{{classname}}",nullptr)
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}
{{#vars}}    ,m_{{name}}()
    ,m_{{name}}_validator({{>model-validator-params}})
{{/vars}}
{
    this->fromJSON(json, as_request);
}

{{classname}}::~{{classname}}()
{
}

{{classname}} &{{classname}}::operator=(const {{classname}} &other)
{
    {{^hasVars}}{{#isEnum}}{{#allowableValues}}
    m_value = other.m_value;
    m_validator = other.m_validator;
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    m_value = other.m_value;
    m_strValue = other.m_strValue;
    m_validator = other.m_validator;
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}{{#vars}}
    m_{{name}} = other.m_{{name}};
    m_{{name}}_validator = other.m_{{name}}_validator;
    {{/vars}}

    return *this;
}

{{classname}} &{{classname}}::operator=({{classname}} &&other)
{
    {{^hasVars}}{{#isEnum}}{{#allowableValues}}
    m_value = std::move(other.m_value);
    m_validator = std::move(other.m_validator);
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    m_value = std::move(other.m_value);
    m_strValue = std::move(other.m_strValue);
    m_validator = std::move(other.m_validator);
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}{{#vars}}
    m_{{name}} = std::move(other.m_{{name}});
    m_{{name}}_validator = std::move(other.m_{{name}}_validator);
    {{/vars}}

    return *this;
}

void {{classname}}::fromJSON(const CJson &json, bool as_request)
{
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    fromString(static_cast<std::string>(json));
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    fromString(static_cast<std::string>(json));
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}{{#vars}}
    static const char *{{name}}_key = "{{baseName}}";
    CJson {{name}}_json = CJson::Null;
    {{#isReadOnly}}
    if (!as_request) {
    {{/isReadOnly}}
    {{#isWriteOnly}}
    if (as_request) {
    {{/isWriteOnly}}

    {{name}}_json = json.getObjectItemCaseSensitive({{name}}_key);
    if (!{{name}}_json.isNull()) {
        {{#isContainer}}
        {{#isArray}}
	if (!{{name}}_json.isArray()) {
	    throw ModelException("Field \"{{{baseName}}}\" is not an array", "{{classname}}", {{name}}_key);
	}
        {{name}}Type {{name}}_list;
        {{name}}Type::value_type element;
        for (auto var : {{name}}_json) {
            {{#items}}
            {{#isPrimitiveType}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isPrimitiveType}}
            {{^isPrimitiveType}}
            {{#isString}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isString}}
            {{#isDate}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isDate}}
            {{#isDateTime}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isDateTime}}
            {{#isByteArray}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isByteArray}}
            {{^isString}}{{^isDate}}{{^isDateTime}}{{^isByteArray}}
            try {
                element.reset(new {{name}}Type::value_type::element_type(var, as_request));
            } catch (ModelException ex) {
                throw ModelException(ex.what(), "{{classname}}", std::string({{name}}_key) + "." + ex.parameter);
            }
            {{/isByteArray}}{{/isDateTime}}{{/isDate}}{{/isString}}
            {{/isPrimitiveType}}
            {{/items}}
            {{name}}_list.push_back(std::move(element));
        }
        m_{{name}} = {{name}}_list;
        {{/isArray}}

        {{#isMap}}
        if (!{{name}}_json.isObject()) {
            throw ModelException("Field \"{{{baseName}}}\" is not an object", "{{classname}}", {{name}}_key);
        }

        {{name}}Type {{name}}_map;
        {{name}}Type::value_type element;
        for (auto var : {{name}}_json) {
            {{#items}}
            {{#isPrimitiveType}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isPrimitiveType}}
            {{^isPrimitiveType}}
            {{#isString}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isString}}
            {{#isDate}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isDate}}
            {{#isDateTime}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isDateTime}}
            {{#isByteArray}}
            element = static_cast<{{name}}Type::value_type>(var);
            {{/isByteArray}}
            {{^isString}}{{^isDate}}{{^isDateTime}}{{^isByteArray}}
            try {
                element.reset(new {{name}}Type::value_type::element_type(var, as_request));
            } catch (ModelException ex) {
                throw ModelException(ex.what(), "{{classname}}", std::string({{name}}_key) + "." + ex.parameter);
            }
            {{/isByteArray}}{{/isDateTime}}{{/isDate}}{{/isString}}
            {{/isPrimitiveType}}
            {{/items}}
            {{name}}_map.insert(std::make_pair(var.key, element));
        }
        m_{{name}} = {{name}}_map;
        {{/isMap}}
        {{/isContainer}}
        {{^isContainer}}
        {{#isPrimitiveType}}
        m_{{name}} = static_cast<{{name}}Type>({{name}}_json);
        {{/isPrimitiveType}}
        {{^isPrimitiveType}}
        {{#isString}}
        m_{{name}} = static_cast<{{name}}Type>({{name}}_json);
        {{/isString}}
        {{#isDate}}
        m_{{name}} = static_cast<{{name}}Type>({{name}}_json);
        {{/isDate}}
        {{#isDateTime}}
        m_{{name}} = static_cast<{{name}}Type>({{name}}_json);
        {{/isDateTime}}
        {{#isByteArray}}
        m_{{name}} = static_cast<{{name}}Type>({{name}}_json);
        {{/isByteArray}}
        {{^isString}}{{^isDate}}{{^isDateTime}}{{^isByteArray}}
        m_{{name}}.reset(new {{name}}Type::element_type({{name}}_json, as_request));
        {{/isByteArray}}{{/isDateTime}}{{/isDate}}{{/isString}}
        {{/isPrimitiveType}}
        {{/isContainer}}

        m_{{name}}_validator.validate(m_{{name}});
    }

    {{#isReadOnly}}
    }
    {{/isReadOnly}}
    {{#isWriteOnly}}
    }
    {{/isWriteOnly}}
    {{/vars}}
}

CJson {{classname}}::toJSON(bool as_request) const
{
{{^hasVars}}{{#isEnum}}{{#allowableValues}}
    return CJson::newString(getString());
{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}
    return CJson::newString(getString());
{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}{{#vars}}
    CJson object = CJson::newObject();

    {{#isReadOnly}}
    if (!as_request) {
    {{/isReadOnly}}
    {{#isWriteOnly}}
    if (as_request) {
    {{/isWriteOnly}}

    {{#isContainer}}

    {{#isArray}}
    {{#items}}
    auto &{{name}}_list = {{getter}}();
    CJson {{name}}_arr = CJson::newArray();

    for(auto& var : {{name}}_list) {
        {{#isPrimitiveType}}
        {{name}}_arr.append(var);
        {{/isPrimitiveType}}
        {{^isPrimitiveType}}
        {{#isString}}
        {{name}}_arr.append(var);
        {{/isString}}
        {{#isDate}}
        {{name}}_arr.append(var);
        {{/isDate}}
        {{#isDateTime}}
        {{name}}_arr.append(var);
        {{/isDateTime}}
        {{#isByteArray}}
        {{name}}_arr.append(var);
        {{/isByteArray}}
        {{^isString}}{{^isDate}}{{^isDateTime}}{{^isByteArray}}
        {{name}}_arr.append(var->toJSON(as_request));
        {{/isByteArray}}{{/isDateTime}}{{/isDate}}{{/isString}}
        {{/isPrimitiveType}}
    }
    object.set("{{name}}", {{name}}_arr);
    {{/items}}
    {{/isArray}}

    {{#isMap}}
    {{#items}}
    auto &{{name}}_map = {{getter}}();
    CJson {{name}}_obj = CJson::newObject();

    for(auto& var : {{name}}_map) {
        {{name}}_obj.set(var.first, CJson::wrap(var.second, as_request));
    }
    object.set("{{name}}", {{name}}_obj);
    {{/items}}
    {{/isMap}}

    {{/isContainer}}
    {{^isContainer}}
    object.set("{{name}}", CJson::wrap({{getter}}(), as_request));
    {{/isContainer}}

    {{#isReadOnly}}
    }
    {{/isReadOnly}}
    {{#isWriteOnly}}
    }
    {{/isWriteOnly}}
    {{/vars}}

    return object;
}

{{^hasVars}}{{#isEnum}}{{#allowableValues}}
const std::string &{{classname}}::getString() const
{
    static const std::string s_null();

    switch(m_value) {
{{#values}}
    case Enum::VAL_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}:
        return STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}};
{{/values}}
    }
    return s_null;
}

{{classname}} &{{classname}}::fromString(const std::string &value)
{
    if (value.empty()) {
        m_value = Enum::NO_VAL;
{{#values}}
    } elif (value == STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}) {
        m_value = Enum::VAL_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}};
{{/values}}
    }
    return *this;
}

{{/allowableValues}}{{/isEnum}}{{^isEnum}}{{#composedSchemas}}{{^oneOf}}{{^allOf}}{{^anyOf.2.name}}{{#anyOf.1.isString}}{{#anyOf.0.isEnumRef}}

{{classname}} &{{classname}}::fromString(const std::string &value)
{
    m_strValue = value;
    m_value = Enum::OTHER;
    if (value.empty()) {
        m_value = Enum::NO_VAL;
{{#anyOf.0.allowableValues.values}}
    } elif (value == STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}) {
        m_value = Enum::VAL_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}};
{{/anyOf.0.allowableValues.values}}
    }
    return *this;
}

std::string {{classname}}::__toString({{classname}}::Enum value)
{
    std::string ret;

    switch(value) {
{{#anyOf.0.allowableValues.values}}
    case {{classname}}::Enum::VAL_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}}:
        return {{classname}}::STR_{{#lambda.uppercase}}{{#lambda.snakecase}}{{.}}{{/lambda.snakecase}}{{/lambda.uppercase}};
{{/anyOf.0.allowableValues.values}}
    }

    return ret;
}

{{/anyOf.0.isEnumRef}}{{/anyOf.1.isString}}{{/anyOf.2.name}}{{/allOf}}{{/oneOf}}{{/composedSchemas}}{{/isEnum}}{{/hasVars}}{{#vars}}
{{#isBoolean}}const {{classname}}::{{name}}Type &{{classname}}::get{{name}}() const
{
    return m_{{name}};
}

{{classname}}::{{name}}Type {{classname}}::{{getter}}() const{{/isBoolean}}{{^isBoolean}}const {{classname}}::{{name}}Type &{{classname}}::{{getter}}() const{{/isBoolean}}
{
    return m_{{name}};
}

bool {{classname}}::{{setter}}(const {{classname}}::{{name}}Type &{{name}})
{
    m_{{name}} = {{name}};
    return true;
}

bool {{classname}}::{{setter}}({{classname}}::{{name}}Type &&{{name}})
{
    m_{{name}} = std::move({{name}});
    return true;
}

{{#isContainer}}
bool {{classname}}::add{{name}}({{#isMap}}const std::string &key, {{/isMap}}const {{classname}}::{{name}}ItemType &item)
{
    {{#isMap}}{{name}}ItemType::value_type entry = std::make_pair(std::string(key), {{name}}ItemType(item));{{/isMap}}
    {{#isMap}}const auto [it, success] = {{/isMap}}m_{{name}}.insert({{#isMap}}std::move(entry){{/isMap}}{{^isMap}}m_{{name}}.end(), item{{/isMap}});
    return {{#isMap}}success{{/isMap}}{{^isMap}}true{{/isMap}};
}

bool {{classname}}::add{{name}}({{#isMap}}const std::string &key, {{/isMap}}{{classname}}::{{name}}ItemType &&item)
{
    {{#isMap}}{{name}}ItemType::value_type entry = std::make_pair(std::string(key), {{name}}ItemType(std::move(item)));{{/isMap}}
    {{#isMap}}const auto [it, success] = {{/isMap}}m_{{name}}.insert({{#isMap}}std::make_pair(key,std::move(item)){{/isMap}}{{^isMap}}m_{{name}}.end(), std::move(item){{/isMap}});
    return {{#isMap}}success{{/isMap}}{{^isMap}}true{{/isMap}};
}

bool {{classname}}::remove{{name}}({{#isMap}}const std::string &key{{/isMap}}{{^isMap}}const {{classname}}::{{name}}ItemType &item{{/isMap}})
{
    {{#isMap}}
    return m_{{name}}.erase(key) == 1;
    {{/isMap}}{{^isMap}}
    m_{{name}}.remove(item);
    return true;
    {{/isMap}}
}

{{#isMap}}
const std::string &{{classname}}::keyFor{{name}}(const {{classname}}::{{name}}ItemType &item)
{
    static const std::string s_null;

    for (auto it : m_{{name}}) {
        if (it.second == item) return it.first;
    }

    return s_null;
}

{{/isMap}}
bool {{classname}}::clear{{name}}()
{
    m_{{name}}.clear();
    return true;
}

{{/isContainer}}
{{/vars}}
{{#modelNamespace}}

} /* end namespace */
{{/modelNamespace}}

{{/model}}
{{/models}}

/* vim:ts=8:sts=4:sw=4:expandtab:
 */
